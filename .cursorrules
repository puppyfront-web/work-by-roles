# Multi-Role Workflow Rules

You are operating within a structured Multi-Role Skills Workflow. 
To ensure project stability and follow best practices, adhere to these rules:

## üé≠ Role-Based Execution (Cursor IDE Integration)

**CRITICAL: When user mentions @role_name, automatically use that role's skills**

**Execution modes are defined in skill metadata using generic fields (not Cursor-specific). Each skill defines:**
- `execution_mode`: "analysis", "implementation", or "validation" (generic, works across all environments)
- `execution_tools`: List of generic tools (e.g., ["file_write", "file_modify", "file_read", "code_search", "command_execute"])
- `execution_capabilities`: List of capabilities (e.g., ["write_code", "write_tests"])

**Tool Mapping**: Generic tools are automatically mapped to environment-specific tools (e.g., `file_write` ‚Üí `write` in Cursor, `file_modify` ‚Üí `search_replace` in Cursor)


1. **Role Invocation via @mention**:
   - When user types `@role_name`, you MUST:
     a. Load the role configuration from `.workflow/role_schema.yaml`
     b. Identify the role's `required_skills` from skill definitions
     c. **Execution mode is determined by skills' `execution_mode` metadata** (generic, not Cursor-specific):

   **Analysis Mode** (skills define: `execution_mode: analysis`):
   - Roles: product_analyst, system_architect
   - These roles focus on analysis, design, and documentation
   - Use `workflow role-execute <role_id> "<requirement>" --use-llm` to execute
   - Skills define capabilities like: write_documentation, create_requirements_doc, write_architecture_doc
   - Example: `@product_analyst ÂàÜÊûêÁî®Êà∑ÈúÄÊ±Ç` ‚Üí Execute `workflow role-execute product_analyst "ÂàÜÊûêÁî®Êà∑ÈúÄÊ±Ç" --use-llm`

   **Implementation Mode** (skills define: `execution_mode: implementation`):
   - Roles: core_framework_engineer
   - **CRITICAL: These roles MUST directly execute code operations, NOT just analysis**
   - When mentioned, you MUST:
     1. Understand the requirement
     2. **Directly use Cursor's tools** (mapped from skills' generic `execution_tools`):
        - Available tools: codebase_search, read_file, run_terminal_cmd, search_replace, write
     3. Use capabilities defined in skills: create_test_files, create_modules, write_tests, implement_functions, verify_test_coverage, modify_code, write_code, run_tests, select_programming_language
     4. **Actually implement** - create/modify files, write code, write tests
     5. Do NOT just call `workflow role-execute` and return analysis - you must ACTUALLY WRITE CODE
   - Example: `@core_framework_engineer ÂÆûÁé∞Áî®Êà∑ËÆ§ËØÅÊ®°Âùó` ‚Üí 
     * Read requirements/architecture docs
     * Use `write` to create Python files in appropriate directories
     * Use `search_replace` to modify existing code
     * Write tests using defined test tools

   **Validation Mode** (skills define: `execution_mode: validation`):
   - Roles: qa_reviewer
   - These roles focus on testing, validation, and quality assurance
   - Use tools defined in skills' `execution_tools` (mapped to Cursor tools) to run tests and validate functionality
   - Available tools: codebase_search, read_file, run_terminal_cmd, write
   - Capabilities: validate_functionality, check_code_quality, generate_test_reports, run_tests, verify_delivery_requirements

   **Important**: Execution mode and tools are defined in skill metadata using generic fields (`execution_mode`, `execution_tools`), not Cursor-specific. These are automatically mapped to Cursor tools when generating rules.


2. **Team Workflow via @team**:
   - When user mentions `@team` or `@[team]`, immediately execute `workflow wfauto` to run the complete workflow
   - This triggers all stages sequentially: requirements ‚Üí architecture ‚Üí implementation ‚Üí validation
   - Example: `@team ÂÆûÁé∞Áî®Êà∑ÁôªÂΩïÂäüËÉΩ` ‚Üí Execute `workflow wfauto --intent "ÂÆûÁé∞Áî®Êà∑ÁôªÂΩïÂäüËÉΩ"`


Available roles (use @role_name to invoke): product_analyst, system_architect, core_framework_engineer, qa_reviewer

## üìã Core Rules

1. **Role Awareness**: Before making changes, check the workflow state file to identify the current active stage and role.
2. **Constraint Enforcement**: Respect the `allowed_actions` and `forbidden_actions` defined in the role schema for the current role.
3. **Stage Boundaries**: 
   - Do not skip stages.
   - Do not perform implementation tasks while in the `requirements` or `architecture` stages.
   - If the current stage does not match the task, advise the user to run `workflow start <stage> <role>`.
4. **Quality Gates**: Ensure all quality gates and required outputs defined in the workflow schema are satisfied before attempting to complete a stage.
5. **Skill Compliance**: 
   - **CRITICAL**: Execution mode is determined by skills, not roles
   - Check each skill's `metadata.execution_mode` (generic field) to determine how to execute
   - Use tools defined in skill's `metadata.execution_tools` (generic, mapped to environment-specific tools)
   - Apply capabilities from skill's `metadata.execution_capabilities`
   - Skills define what you can do using generic, environment-agnostic definitions
6. **Skill-Based Execution**:
   - **Analysis skills** (`execution_mode: analysis`): Use `workflow role-execute` for analysis and documentation
   - **Implementation skills** (`execution_mode: implementation`): Directly use tools (mapped from generic `execution_tools`) to write/modify code files
   - **Validation skills** (`execution_mode: validation`): Use tools to run tests and validate functionality
   - Always check skill metadata to determine execution approach, not role names
   - Skills use generic tool names that are automatically mapped to environment-specific tools
7. **Agent Execution**:
   - For automated execution, use `workflow agent-execute [stage]`.
   - When acting as an agent, follow the `instruction_template` in the role definition and the `goal_template` in the stage definition.
7. **Team Context & Auto Workflow Execution**: 
   - **CRITICAL: Fully Automated Execution**:
     - **Every @[team] mention**: When user mentions `@[team]` or `@team`, **immediately execute** `workflow wfauto` to run the complete workflow with Agent + Skills automation. This is the default behavior - no explicit request needed.
     - **Fully Automated**: Execute the complete workflow automatically without asking for confirmation at each step. Only pause if critical issues arise (e.g., API keys, environment configuration, external dependencies).
     - **No User Intervention**: The workflow runs end-to-end automatically, similar to Lovable/MetaGPT. Do not ask "Should I proceed?" or "Is this okay?" - just execute.
   - When user mentions `@[team]`, `@team`, or asks about "team workflow", **immediately read** the TEAM_CONTEXT.md file (if exists).
   - Current team configuration is loaded from the active team context.
   - The `workflow wfauto` command automatically:
     - Uses AgentOrchestrator for multi-agent collaboration
     - Automatically selects and executes relevant skills for each stage
     - Runs skill workflows with auto-trigger
     - Uses relaxed quality gates (won't block on failures)
     - Completes all stages without user intervention (except for critical issues)

# DYNAMIC_CONTEXT_ANCHOR
CURRENT_STAGE: None
CURRENT_ROLE: None

Current project status can be viewed at any time by running `workflow status`.
